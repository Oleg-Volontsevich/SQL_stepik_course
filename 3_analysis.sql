-- analysis_data_base

-- Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова MAX и AVG 
-- одновременно. Для шагов указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, 
-- после позиции шага перед заголовком - пробел. Позицию шага в уроке вывести в виде двух цифр 
-- (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать Шаг. 
-- Информацию отсортировать по первому столбцу в алфавитном порядке.

SELECT CONCAT(module_id, '.', lesson_position, '.', RIGHT(CONCAT(0, step_position), 2), ' ', step_name) AS Шаг 

FROM step_keyword JOIN step USING(step_id)
                  JOIN lesson USING(lesson_id)
                  JOIN module USING(module_id)
                  JOIN keyword USING(keyword_id)
WHERE keyword_name IN ('MAX', 'AVG')
GROUP BY step_id
HAVING COUNT(keyword_name)>1 
ORDER BY 1;

--------------------------------------------------------------------------
-- Вычислить прогресс пользователей по курсу. Прогресс вычисляется как отношение верно пройденных шагов 
-- к общему количеству шагов в процентах, округленное до целого. 
-- В нашей базе данные о решениях занесены не для всех шагов, поэтому общее количество шагов определить
--  как количество различных шагов в таблице step_student.
-- Тем пользователям, которые прошли все шаги (прогресс = 100%) выдать "Сертификат с отличием". 
-- Тем, у кого прогресс больше или равен 80% -  "Сертификат". 
-- Для остальных записей в столбце Результат задать пустую строку ("").
-- Информацию отсортировать по убыванию прогресса, затем по имени пользователя в алфавитном порядке.

SELECT *, IF (Прогресс = 100, 'Сертификат с отличием', IF(Прогресс <80, '', 'Сертификат')) AS Результат
FROM
    (
    SELECT Студент, 
        ROUND (SUM(IF (Верно>0, 1, 0))/(SELECT COUNT(DISTINCT step_id) FROM step_student)*100) AS Прогресс 
    FROM 
        (
        SELECT student_name AS Студент, step_id, SUM(IF(result='correct', 1, 0)) AS Верно
        FROM step_student JOIN student USING(student_id)
        GROUP BY 1, step_id
        ORDER BY 1
        ) AS sq1
    GROUP BY 1
    ) AS sq2
ORDER BY 2 DESC, 1;

--------------------------------------------------------------------------
-- Посчитать среднее время, за которое пользователи проходят урок по следующему алгоритму:
--     для каждого пользователя вычислить время прохождения шага как сумму времени, потраченного на каждую попытку 
-- (время попытки - это разница между временем отправки задания и временем начала попытки), 
-- при этом попытки, которые длились больше 4 часов не учитывать, так как пользователь мог просто оставить задание открытым, 
-- а вернуться к нему на следующий день;
--     для каждого студента посчитать общее время, которое он затратил на каждый урок;
--     вычислить среднее время выполнения урока в часах, результат округлить до 2-х знаков после запятой;
--     вывести информацию по возрастанию времени, пронумеровав строки, для каждого урока указать номер модуля и его позицию в нем.
-- Столбцы результата назвать Номер, Урок, Среднее_время.

SELECT ROW_NUMBER() OVER (ORDER BY ROUND(avg_les_time, 2)) AS Номер,
       CONCAT( module_id, '.', lesson_position, ' ', lesson_name) AS Урок,
       avg_les_time AS Среднее_время
FROM
    (
    SELECT lesson_id, 
           ROUND(AVG(sum_lesson_time)/(60*60), 2) AS avg_les_time
    FROM 
        (
        SELECT student_id, lesson_id, SUM(submission_time - attempt_time) AS sum_lesson_time
        FROM step_student JOIN step USING(step_id)
        WHERE (submission_time - attempt_time) < 4*60*60
        GROUP BY 1, 2
        ORDER BY 1, 2
        ) AS q1
    GROUP BY lesson_id
    ) AS q2 
JOIN lesson USING(lesson_id)
JOIN module USING(module_id);